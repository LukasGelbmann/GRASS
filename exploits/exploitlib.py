"""Helpers for making exploits.

This module requires Python 3.6 or higher."""


import pathlib
import shutil
import subprocess
import sys
import time


# `HERE` is the directory this module is located in.
HERE = pathlib.Path(__file__).resolve().parent
TEMP_DIR = HERE / 'temp'
BIN_DIR = HERE.parent / 'bin'
BASE_CONFIG = HERE / 'grass.conf'
EXPLOIT_FILENAME = 'exploit.in'

CLIENT = 'client'
SERVER = 'server'
BINARIES = CLIENT, SERVER
CLIENT_PATH = TEMP_DIR / CLIENT
SERVER_PATH = TEMP_DIR / SERVER
CONFIG_PATH = TEMP_DIR / 'grass.conf'
REPO_DIR = TEMP_DIR / 'repo'
IP_ADDRESS = '127.0.0.1'
PORT = 6543

STARTUP_WAIT = 0.1
END_WAIT = 0.1
TIMEOUT = 3.0

HIJACK_ADDRESS = b'\x7b\xbf\x05\x08'


def run(exploit_dir=None, exploit_bytes=None):
    """Run a full exploit."""

    if exploit_bytes is None:
        exploit_path = exploit_dir / EXPLOIT_FILENAME
        exploit_bytes = exploit_path.read_bytes()

    try:
        if setup():
            run_system(exploit_bytes)
    finally:
        cleanup()


def setup():
    """Perform setup and return True if it succeeded."""

    try:
        TEMP_DIR.mkdir(exist_ok=True)
    except OSError:
        print("Error in setup: couldn't make temporary directory")
        return False

    # Copy the binaries into the temporary directory because the server must be
    # in the same directory as the config file.
    for binary in BINARIES:
        try:
            shutil.copy(BIN_DIR / binary, TEMP_DIR / binary)
        except OSError:
            print(f"Error in setup: couldn't copy {binary}.  (Run `make`!)")
            return False

    try:
        shutil.copy(BASE_CONFIG, CONFIG_PATH)
    except OSError:
        print("Error in setup: couldn't copy config")
        return False

    return True


def cleanup():
    """Clean up afterwards."""

    try:
        CONFIG_PATH.unlink()
    except OSError:
        print("Error in cleanup: couldn't remove config file")

    for binary in BINARIES:
        try:
            (TEMP_DIR / binary).unlink()
        except OSError:
            print(f"Error in cleanup: couldn't remove {binary}")

    try:
        TEMP_DIR.rmdir()
    except OSError as e:
        print(f"Error in cleanup: couldn't delete temporary directory: {e}")


def run_system(in_bytes):
    """Run a client and server and print the server output.

    Raise a `subprocess.SubprocessError` on error."""

    print(present_output(in_bytes, "CLIENT INPUT"))

    kwargs = dict(stdout=subprocess.PIPE, stderr=subprocess.DEVNULL,
                  cwd=TEMP_DIR)

    with subprocess.Popen(str(SERVER_PATH), **kwargs) as server:
        try:
            time.sleep(STARTUP_WAIT)
            args = str(CLIENT_PATH), IP_ADDRESS, str(PORT)
            client = subprocess.run(args, **kwargs, input=in_bytes,
                                    timeout=TIMEOUT)
            # print(present_output(client.stdout, "CLIENT OUTPUT"))
        finally:
            time.sleep(END_WAIT)
            server.kill()
            try:
                shutil.rmtree(REPO_DIR)
            except OSError as e:
                print(f"Warning in cleanup: Couldn't remove repo: {e}")

        server_output, _ = server.communicate()

    print(present_output(server_output, "SERVER OUTPUT"))


def present_output(text_bytes, title):
    """Return the bytes in a readable representation."""
    text = escape_decode(text_bytes)
    return prominent(title) + '\n' + text + prominent(f"END {title}")


def prominent(text):
    """Return a prominently displayed version of the text."""
    return f"----- {text} -----"


def escape_decode(text_bytes):
    """Decode bytes with ASCII encoding, escaping non-printable characters."""
    text = text_bytes.decode('latin-1')
    escaped = (char if char == '\n' else ascii(char)[1:-1] for char in text)
    return ''.join(escaped)
